#!/usr/bin/env python3

import os
import re
import json
import argparse
import sys
from pathlib import Path

# Regex to find named exports, covering:
# - export const Component = ...
# - export function Component(...) ...
# - export { Component, Component2 } from ...
# - export { Component as Alias } from ...
# - export default ... (ignored for now)
EXPORT_REGEX = re.compile(
    r"""^\s*export\s+"
    r"""(?:const|function|class|type|interface|enum)\s+([A-Z][\w]*)""" # export const MyComponent
    r"""|\{([^}]+)\}"""  # export { MyComponent, MyAlias as Alias }
    , re.MULTILINE
)

# Regex to parse the content of export { ... }
COMPONENT_IN_BRACES_REGEX = re.compile(r"""([A-Za-z0-9_]+)(?:\s+as\s+([A-Za-z0-9_]+))?""")

def find_exports(file_path):
    """Finds all named exports in a given TypeScript file."""
    try:
        with open(file_path, 'r') as f:
            content = f.read()
    except IOError:
        return []

    found_components = set()
    matches = EXPORT_REGEX.finditer(content)

    for match in matches:
        # Case 1: export const/function/class ComponentName
        if match.group(1):
            found_components.add(match.group(1))
        # Case 2: export { Component1, Component2 as Alias }
        elif match.group(2):
            components_str = match.group(2)
            inner_matches = COMPONENT_IN_BRACES_REGEX.finditer(components_str)
            for inner_match in inner_matches:
                # Use the alias if it exists, otherwise the original name
                component_name = inner_match.group(2) or inner_match.group(1)
                found_components.add(component_name)

    return list(found_components)

def main():
    parser = argparse.ArgumentParser(description="Scans the component library and automatically generates the component registry file.")
    parser.add_argument("--scan-dir", required=True, help="The directory containing the React components to be registered.")
    parser.add_argument("--output-file", required=True, help="The path to the output component-registry.ts file.")
    parser.add_argument("--base-registry", help="Optional path to a JSON file defining a base set of components.")
    parser.add_argument("--wildcard-export-files", default='["index.ts", "index.tsx"]', help="JSON array of filenames that use wildcard exports.")

    args = parser.parse_args()

    wildcard_files = json.loads(args.wildcard_export_files)
    registry = {}
    imports = {}

    # Load base registry if provided
    if args.base_registry:
        try:
            with open(args.base_registry, 'r') as f:
                base_components = json.load(f)
            for name, source in base_components.items():
                if source not in imports:
                    imports[source] = set()
                imports[source].add(name)
                registry[name] = name
            print(f"Loaded {len(base_components)} components from base registry.")
        except (IOError, json.JSONDecodeError) as e:
            print(f"Warning: Could not load or parse base registry file: {e}", file=sys.stderr)

    # Scan the directory
    output_path = Path(args.output_file).resolve()
    scan_path = Path(args.scan_dir).resolve()

    for root, _, files in os.walk(scan_path):
        for file in files:
            if not (file.endswith(".tsx") or file.endswith(".ts")):
                continue

            file_path = Path(root) / file
            components = find_exports(file_path)

            if components:
                relative_path = os.path.relpath(file_path, output_path.parent)
                # Convert to a JS-style path
                import_source = f"./{relative_path.replace(os.sep, '/')}".replace(".tsx", "").replace(".ts", "")

                if import_source not in imports:
                    imports[import_source] = set()

                for comp in components:
                    imports[import_source].add(comp)
                    registry[comp] = comp

    # Generate the output file content
    import_statements = []
    for source, names in imports.items():
        import_statements.append(f"import {{ {', '.join(sorted(list(names)))} }} from '{source}';")

    mapper_entries = []
    for name in sorted(registry.keys()):
        mapper_entries.append(f"  '{name}': {name},")

    output_content = (
        "// This file is auto-generated by the `smartspec_generate_component_registry` workflow. DO NOT EDIT.\n\n"
        "import React from 'react';\n"
        f"{'\n'.join(import_statements)}\n\n"
        "export const ComponentMapper: Record<string, React.ComponentType<any>> = {\n"
        f"{'\n'.join(mapper_entries)}\n"
        "};\n"
    )

    # Write the output file
    try:
        os.makedirs(output_path.parent, exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(output_content)
        print(f"ðŸŽ‰ Successfully generated component registry with {len(registry)} components at: {args.output_file}")
    except IOError as e:
        print(f"Error: Failed to write output file: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
