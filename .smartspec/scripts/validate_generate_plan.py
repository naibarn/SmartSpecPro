#!/usr/bin/env python3
"""
Validate Generate Plan - SmartSpec Workflow Validator

Validates implementation plans generated by generate_plan workflow to ensure:
- Clear milestones and phases
- Realistic timelines
- Resource allocation
- Risk assessment
- Dependencies identified
- Naming conventions followed

Auto-fixes common issues when possible.
"""

import json
import sys
import re
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional
from datetime import datetime

class GeneratePlanValidator:
    """Validator for generate_plan workflow output"""
    
    # Required sections in an implementation plan
    REQUIRED_SECTIONS = [
        "overview",
        "milestones",
        "phases",
        "timeline",
        "resources",
        "dependencies"
    ]
    
    # Optional but recommended sections
    RECOMMENDED_SECTIONS = [
        "risks",
        "assumptions",
        "success_criteria",
        "rollback_plan",
        "communication_plan"
    ]
    
    def __init__(self, plan_file: Path, repo_root: Optional[Path] = None):
        """
        Initialize validator
        
        Args:
            plan_file: Path to plan file
            repo_root: Repository root for validating paths
        """
        self.plan_file = Path(plan_file)
        self.repo_root = Path(repo_root) if repo_root else self.plan_file.parent
        self.issues = []
        self.fixes_applied = []
        self.plan_data = None
        
    def load_plan(self) -> bool:
        """Load plan file"""
        try:
            if self.plan_file.suffix == '.json':
                with open(self.plan_file, 'r', encoding='utf-8') as f:
                    self.plan_data = json.load(f)
            elif self.plan_file.suffix == '.md':
                self.plan_data = self._parse_markdown()
            else:
                self.issues.append({
                    'type': 'error',
                    'message': f'Unsupported file type: {self.plan_file.suffix}',
                    'fixable': False
                })
                return False
            return True
        except Exception as e:
            self.issues.append({
                'type': 'error',
                'message': f'Failed to load plan: {str(e)}',
                'fixable': False
            })
            return False
    
    def _parse_markdown(self) -> Dict[str, Any]:
        """Parse markdown plan into structured data"""
        with open(self.plan_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        plan = {}
        current_section = None
        current_content = []
        
        for line in content.split('\n'):
            if line.startswith('## '):
                if current_section:
                    plan[current_section] = '\n'.join(current_content).strip()
                current_section = line[3:].strip().lower().replace(' ', '_')
                current_content = []
            elif current_section:
                current_content.append(line)
        
        if current_section:
            plan[current_section] = '\n'.join(current_content).strip()
        
        return plan
    
    def validate_structure(self) -> None:
        """Validate plan structure"""
        if not isinstance(self.plan_data, dict):
            self.issues.append({
                'type': 'error',
                'message': 'Plan must be a dictionary/object',
                'fixable': False
            })
            return
        
        # Check required sections
        for section in self.REQUIRED_SECTIONS:
            if section not in self.plan_data:
                self.issues.append({
                    'type': 'error',
                    'section': section,
                    'message': f'Missing required section: {section}',
                    'fixable': True,
                    'fix': 'add_section'
                })
            elif not self.plan_data[section] or not str(self.plan_data[section]).strip():
                self.issues.append({
                    'type': 'warning',
                    'section': section,
                    'message': f'Section "{section}" is empty',
                    'fixable': True,
                    'fix': 'add_placeholder'
                })
        
        # Check recommended sections
        for section in self.RECOMMENDED_SECTIONS:
            if section not in self.plan_data:
                self.issues.append({
                    'type': 'info',
                    'section': section,
                    'message': f'Recommended section missing: {section}',
                    'fixable': True,
                    'fix': 'add_section'
                })
    
    def validate_milestones(self) -> None:
        """Validate milestones section"""
        if 'milestones' not in self.plan_data:
            return
        
        milestones = str(self.plan_data['milestones'])
        
        # Check for milestone definitions
        milestone_patterns = [
            r'(?:^|\n)[-*]\s+\*\*(.+?)\*\*',  # - **Milestone Name**
            r'(?:^|\n)#{3,4}\s+(.+)',  # ### Milestone Name
        ]
        
        found_milestones = []
        for pattern in milestone_patterns:
            matches = re.findall(pattern, milestones, re.MULTILINE)
            found_milestones.extend(matches)
        
        if len(found_milestones) < 2:
            self.issues.append({
                'type': 'warning',
                'section': 'milestones',
                'message': f'Only {len(found_milestones)} milestone(s) found (recommend 2+)',
                'fixable': False
            })
        
        # Check for dates
        date_patterns = [
            r'\d{4}-\d{2}-\d{2}',  # 2024-01-15
            r'\d{2}/\d{2}/\d{4}',  # 01/15/2024
            r'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2},?\s+\d{4}',  # Jan 15, 2024
        ]
        
        has_dates = any(re.search(pattern, milestones, re.IGNORECASE) for pattern in date_patterns)
        
        if not has_dates:
            self.issues.append({
                'type': 'warning',
                'section': 'milestones',
                'message': 'No dates found in milestones',
                'fixable': False
            })
    
    def validate_phases(self) -> None:
        """Validate phases section"""
        if 'phases' not in self.plan_data:
            return
        
        phases = str(self.plan_data['phases'])
        
        # Check for phase definitions
        phase_patterns = [
            r'(?:^|\n)[-*]\s+\*\*Phase\s+\d+',  # - **Phase 1**
            r'(?:^|\n)#{3,4}\s+Phase\s+\d+',  # ### Phase 1
        ]
        
        found_phases = []
        for pattern in phase_patterns:
            matches = re.findall(pattern, phases, re.MULTILINE | re.IGNORECASE)
            found_phases.extend(matches)
        
        if len(found_phases) < 3:
            self.issues.append({
                'type': 'warning',
                'section': 'phases',
                'message': f'Only {len(found_phases)} phase(s) found (recommend 3+)',
                'fixable': False
            })
        
        # Check for deliverables
        has_deliverables = 'deliverable' in phases.lower()
        
        if not has_deliverables:
            self.issues.append({
                'type': 'info',
                'section': 'phases',
                'message': 'No deliverables mentioned in phases',
                'fixable': False
            })
    
    def validate_timeline(self) -> None:
        """Validate timeline section"""
        if 'timeline' not in self.plan_data:
            return
        
        timeline = str(self.plan_data['timeline'])
        
        # Check for duration mentions
        duration_patterns = [
            r'\d+\s+(day|week|month|sprint)s?',
            r'\d+[dwm]',  # 2w, 3m, etc.
        ]
        
        durations = []
        for pattern in duration_patterns:
            matches = re.findall(pattern, timeline, re.IGNORECASE)
            durations.extend(matches)
        
        if len(durations) < 2:
            self.issues.append({
                'type': 'warning',
                'section': 'timeline',
                'message': 'Timeline lacks specific durations',
                'fixable': False
            })
        
        # Check for start/end dates
        has_start = 'start' in timeline.lower()
        has_end = 'end' in timeline.lower() or 'completion' in timeline.lower()
        
        if not has_start:
            self.issues.append({
                'type': 'info',
                'section': 'timeline',
                'message': 'No start date mentioned',
                'fixable': False
            })
        
        if not has_end:
            self.issues.append({
                'type': 'info',
                'section': 'timeline',
                'message': 'No end date mentioned',
                'fixable': False
            })
    
    def validate_resources(self) -> None:
        """Validate resources section"""
        if 'resources' not in self.plan_data:
            return
        
        resources = str(self.plan_data['resources'])
        
        # Check for resource types
        resource_types = {
            'team': ['developer', 'engineer', 'designer', 'tester', 'qa', 'pm', 'manager'],
            'tools': ['tool', 'software', 'platform', 'service'],
            'infrastructure': ['server', 'database', 'cloud', 'infrastructure'],
        }
        
        found_types = []
        for rtype, keywords in resource_types.items():
            if any(keyword in resources.lower() for keyword in keywords):
                found_types.append(rtype)
        
        if len(found_types) < 2:
            self.issues.append({
                'type': 'info',
                'section': 'resources',
                'message': f'Only {len(found_types)} resource type(s) mentioned (found: {", ".join(found_types)})',
                'fixable': False
            })
    
    def validate_dependencies(self) -> None:
        """Validate dependencies section"""
        if 'dependencies' not in self.plan_data:
            return
        
        dependencies = str(self.plan_data['dependencies'])
        
        # Check for dependency mentions
        dependency_keywords = ['depend', 'require', 'prerequisite', 'block']
        
        has_dependencies = any(keyword in dependencies.lower() for keyword in dependency_keywords)
        
        if not has_dependencies:
            self.issues.append({
                'type': 'warning',
                'section': 'dependencies',
                'message': 'No explicit dependencies identified',
                'fixable': False
            })
        
        # Check for external dependencies
        external_keywords = ['external', 'third-party', 'vendor', 'api']
        has_external = any(keyword in dependencies.lower() for keyword in external_keywords)
        
        if not has_external:
            self.issues.append({
                'type': 'info',
                'section': 'dependencies',
                'message': 'No external dependencies mentioned',
                'fixable': False
            })
    
    def validate_risks(self) -> None:
        """Validate risks section"""
        if 'risks' not in self.plan_data:
            return
        
        risks = str(self.plan_data['risks'])
        
        # Check for risk definitions
        risk_pattern = r'(?:^|\n)[-*]\s+\*\*(.+?)\*\*'
        found_risks = re.findall(risk_pattern, risks, re.MULTILINE)
        
        if len(found_risks) < 2:
            self.issues.append({
                'type': 'info',
                'section': 'risks',
                'message': f'Only {len(found_risks)} risk(s) identified (recommend 2+)',
                'fixable': False
            })
        
        # Check for mitigation strategies
        has_mitigation = 'mitigation' in risks.lower() or 'mitigate' in risks.lower()
        
        if not has_mitigation:
            self.issues.append({
                'type': 'warning',
                'section': 'risks',
                'message': 'No mitigation strategies mentioned',
                'fixable': False
            })
    
    def validate_naming(self) -> None:
        """Validate naming conventions"""
        path_pattern = r'`([^`]+\.(ts|js|py|java|go|rs|md|json|yaml|yml))`'
        
        for section, content in self.plan_data.items():
            if not isinstance(content, str):
                continue
            
            paths = re.findall(path_pattern, content)
            for path, ext in paths:
                filename = Path(path).name
                stem = filename.rsplit('.', 1)[0]
                
                if not self._is_kebab_case(stem):
                    self.issues.append({
                        'type': 'warning',
                        'section': section,
                        'path': path,
                        'message': f'File path not in kebab-case: {path}',
                        'fixable': True,
                        'fix': 'convert_kebab_case'
                    })
    
    def _is_kebab_case(self, name: str) -> bool:
        """Check if name is in kebab-case"""
        return bool(re.match(r'^[a-z0-9]+(-[a-z0-9]+)*(\.[a-z0-9]+)*$', name))
    
    def auto_fix(self) -> None:
        """Apply automatic fixes"""
        for issue in self.issues:
            if not issue.get('fixable'):
                continue
            
            fix_type = issue.get('fix')
            
            if fix_type == 'add_section':
                section = issue.get('section')
                if section and section not in self.plan_data:
                    self.plan_data[section] = f'[TODO: Add {section} section]'
                    self.fixes_applied.append(f'Added section: {section}')
            
            elif fix_type == 'add_placeholder':
                section = issue.get('section')
                if section and not str(self.plan_data.get(section, '')).strip():
                    self.plan_data[section] = f'[TODO: Complete {section} section]'
                    self.fixes_applied.append(f'Added placeholder for: {section}')
    
    def save_plan(self) -> None:
        """Save fixed plan"""
        if self.plan_file.suffix == '.json':
            with open(self.plan_file, 'w', encoding='utf-8') as f:
                json.dump(self.plan_data, f, indent=2, ensure_ascii=False)
        elif self.plan_file.suffix == '.md':
            self._save_markdown()
    
    def _save_markdown(self) -> None:
        """Save plan as markdown"""
        lines = ['# Implementation Plan\n']
        
        for section in self.REQUIRED_SECTIONS + self.RECOMMENDED_SECTIONS:
            if section in self.plan_data:
                title = section.replace('_', ' ').title()
                lines.append(f'## {title}\n')
                lines.append(f'{self.plan_data[section]}\n')
        
        for section, content in self.plan_data.items():
            if section not in self.REQUIRED_SECTIONS + self.RECOMMENDED_SECTIONS:
                title = section.replace('_', ' ').title()
                lines.append(f'## {title}\n')
                lines.append(f'{content}\n')
        
        with open(self.plan_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
    
    def generate_report(self) -> str:
        """Generate validation report"""
        lines = ['# Generate Plan Validation Report\n', f'**File:** `{self.plan_file}`\n']
        
        errors = [i for i in self.issues if i['type'] == 'error']
        warnings = [i for i in self.issues if i['type'] == 'warning']
        infos = [i for i in self.issues if i['type'] == 'info']
        
        lines.append(f'## Summary\n')
        lines.append(f'- **Errors:** {len(errors)}')
        lines.append(f'- **Warnings:** {len(warnings)}')
        lines.append(f'- **Info:** {len(infos)}')
        lines.append(f'- **Fixes Applied:** {len(self.fixes_applied)}\n')
        
        if errors:
            lines.append(f'## Errors\n')
            for issue in errors:
                lines.append(f'- {issue["message"]}')
            lines.append('')
        
        if warnings:
            lines.append(f'## Warnings\n')
            for issue in warnings:
                lines.append(f'- {issue["message"]}')
            lines.append('')
        
        if infos:
            lines.append(f'## Recommendations\n')
            for issue in infos:
                lines.append(f'- {issue["message"]}')
            lines.append('')
        
        if self.fixes_applied:
            lines.append(f'## Fixes Applied\n')
            for fix in self.fixes_applied:
                lines.append(f'- {fix}')
            lines.append('')
        
        return '\n'.join(lines)
    
    def validate(self, apply_fixes: bool = False) -> Tuple[bool, str]:
        """Run full validation"""
        if not self.load_plan():
            return False, self.generate_report()
        
        self.validate_structure()
        self.validate_milestones()
        self.validate_phases()
        self.validate_timeline()
        self.validate_resources()
        self.validate_dependencies()
        self.validate_risks()
        self.validate_naming()
        
        if apply_fixes:
            self.auto_fix()
            if self.fixes_applied:
                self.save_plan()
        
        report = self.generate_report()
        errors = [i for i in self.issues if i['type'] == 'error']
        success = len(errors) == 0
        
        return success, report


def main():
    """CLI interface"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Validate generate_plan workflow output')
    parser.add_argument('plan_file', help='Path to plan file')
    parser.add_argument('--repo-root', help='Repository root directory')
    parser.add_argument('--apply', action='store_true', help='Apply automatic fixes')
    parser.add_argument('--output', help='Output report file')
    
    args = parser.parse_args()
    
    validator = GeneratePlanValidator(args.plan_file, args.repo_root)
    success, report = validator.validate(apply_fixes=args.apply)
    
    print(report)
    
    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(report)
    
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
