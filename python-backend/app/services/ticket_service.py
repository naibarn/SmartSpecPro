"""
Support Ticket Service
Manage user support tickets
"""

from typing import Dict, Any, List, Optional
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
import json

from app.models.support_ticket import (
    SupportTicket,
    TicketMessage,
    TicketStatus,
    TicketPriority,
    TicketCategory
)


class TicketService:
    """Service for support ticket management"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def create_ticket(
        self,
        user_id: str,
        subject: str,
        description: str,
        category: str,
        priority: str = "medium"
    ) -> SupportTicket:
        """
        Create a new support ticket
        
        Args:
            user_id: User ID
            subject: Ticket subject
            description: Ticket description
            category: Ticket category
            priority: Ticket priority
        
        Returns:
            Created ticket
        """
        try:
            ticket = SupportTicket(
                user_id=user_id,
                subject=subject,
                description=description,
                category=TicketCategory(category),
                priority=TicketPriority(priority),
                status=TicketStatus.OPEN,
                ticket_number=""  # Will be auto-generated by trigger
            )
            
            self.db.add(ticket)
            await self.db.commit()
            await self.db.refresh(ticket)
            
            return ticket
        except Exception as e:
            await self.db.rollback()
            raise
    
    async def get_ticket(
        self,
        ticket_id: str,
        user_id: Optional[str] = None
    ) -> Optional[SupportTicket]:
        """
        Get a ticket by ID
        
        Args:
            ticket_id: Ticket ID
            user_id: Optional user ID for ownership check
        
        Returns:
            Ticket if found
        """
        query = select(SupportTicket).where(SupportTicket.id == ticket_id)
        
        if user_id:
            query = query.where(SupportTicket.user_id == user_id)
        
        result = await self.db.execute(query)
        ticket = result.scalar_one_or_none()
        
        return ticket
    
    async def get_tickets(
        self,
        user_id: Optional[str] = None,
        status: Optional[str] = None,
        category: Optional[str] = None,
        priority: Optional[str] = None,
        assigned_to: Optional[str] = None,
        limit: int = 50,
        offset: int = 0
    ) -> List[SupportTicket]:
        """
        Get tickets with filters
        
        Args:
            user_id: Filter by user ID
            status: Filter by status
            category: Filter by category
            priority: Filter by priority
            assigned_to: Filter by assigned admin
            limit: Maximum number of results
            offset: Offset for pagination
        
        Returns:
            List of tickets
        """
        query = select(SupportTicket)
        
        conditions = []
        
        if user_id:
            conditions.append(SupportTicket.user_id == user_id)
        
        if status:
            conditions.append(SupportTicket.status == TicketStatus(status))
        
        if category:
            conditions.append(SupportTicket.category == TicketCategory(category))
        
        if priority:
            conditions.append(SupportTicket.priority == TicketPriority(priority))
        
        if assigned_to:
            conditions.append(SupportTicket.assigned_to == assigned_to)
        
        if conditions:
            query = query.where(and_(*conditions))
        
        query = query.order_by(SupportTicket.created_at.desc())
        query = query.limit(limit).offset(offset)
        
        result = await self.db.execute(query)
        tickets = result.scalars().all()
        
        return tickets
    
    async def update_ticket(
        self,
        ticket_id: str,
        status: Optional[str] = None,
        priority: Optional[str] = None,
        assigned_to: Optional[str] = None
    ) -> Optional[SupportTicket]:
        """
        Update a ticket
        
        Args:
            ticket_id: Ticket ID
            status: New status
            priority: New priority
            assigned_to: Assign to admin
        
        Returns:
            Updated ticket
        """
        try:
            ticket = await self.get_ticket(ticket_id)
            
            if not ticket:
                return None
            
            if status:
                ticket.status = TicketStatus(status)
                
                if status == "resolved":
                    ticket.resolved_at = datetime.utcnow()
                elif status == "closed":
                    ticket.closed_at = datetime.utcnow()
            
            if priority:
                ticket.priority = TicketPriority(priority)
            
            if assigned_to is not None:
                ticket.assigned_to = assigned_to
            
            await self.db.commit()
            await self.db.refresh(ticket)
            
            return ticket
        except Exception as e:
            await self.db.rollback()
            raise
    
    async def add_message(
        self,
        ticket_id: str,
        user_id: str,
        message: str,
        is_staff_response: bool = False,
        attachments: Optional[List[str]] = None
    ) -> TicketMessage:
        """
        Add a message to a ticket
        
        Args:
            ticket_id: Ticket ID
            user_id: User ID
            message: Message text
            is_staff_response: Whether this is from staff
            attachments: List of attachment URLs
        
        Returns:
            Created message
        """
        try:
            ticket_message = TicketMessage(
                ticket_id=ticket_id,
                user_id=user_id,
                message=message,
                is_staff_response="true" if is_staff_response else "false",
                attachments=json.dumps(attachments) if attachments else None
            )
            
            self.db.add(ticket_message)
            
            # Update ticket's updated_at
            ticket = await self.get_ticket(ticket_id)
            if ticket:
                ticket.updated_at = datetime.utcnow()
                
                # If user responds, change status from waiting_user to in_progress
                if not is_staff_response and ticket.status == TicketStatus.WAITING_USER:
                    ticket.status = TicketStatus.IN_PROGRESS
            
            await self.db.commit()
            await self.db.refresh(ticket_message)
            
            return ticket_message
        except Exception as e:
            await self.db.rollback()
            raise
    
    async def get_messages(
        self,
        ticket_id: str
    ) -> List[TicketMessage]:
        """
        Get all messages for a ticket
        
        Args:
            ticket_id: Ticket ID
        
        Returns:
            List of messages
        """
        query = select(TicketMessage).where(
            TicketMessage.ticket_id == ticket_id
        ).order_by(TicketMessage.created_at.asc())
        
        result = await self.db.execute(query)
        messages = result.scalars().all()
        
        return messages
    
    async def get_ticket_statistics(
        self,
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Get ticket statistics
        
        Args:
            user_id: Optional user ID for user-specific stats
        
        Returns:
            Ticket statistics
        """
        query = select(SupportTicket)
        
        if user_id:
            query = query.where(SupportTicket.user_id == user_id)
        
        result = await self.db.execute(query)
        tickets = result.scalars().all()
        
        # Count by status
        status_counts = {}
        for ticket in tickets:
            status = ticket.status.value
            status_counts[status] = status_counts.get(status, 0) + 1
        
        # Count by priority
        priority_counts = {}
        for ticket in tickets:
            priority = ticket.priority.value
            priority_counts[priority] = priority_counts.get(priority, 0) + 1
        
        # Count by category
        category_counts = {}
        for ticket in tickets:
            category = ticket.category.value
            category_counts[category] = category_counts.get(category, 0) + 1
        
        return {
            "total_tickets": len(tickets),
            "by_status": status_counts,
            "by_priority": priority_counts,
            "by_category": category_counts
        }
    
    async def search_tickets(
        self,
        search_term: str,
        user_id: Optional[str] = None,
        limit: int = 50
    ) -> List[SupportTicket]:
        """
        Search tickets
        
        Args:
            search_term: Search term
            user_id: Optional user ID filter
            limit: Maximum number of results
        
        Returns:
            List of matching tickets
        """
        conditions = [
            or_(
                SupportTicket.ticket_number.ilike(f"%{search_term}%"),
                SupportTicket.subject.ilike(f"%{search_term}%"),
                SupportTicket.description.ilike(f"%{search_term}%")
            )
        ]
        
        if user_id:
            conditions.append(SupportTicket.user_id == user_id)
        
        query = select(SupportTicket).where(
            and_(*conditions)
        ).order_by(SupportTicket.created_at.desc()).limit(limit)
        
        result = await self.db.execute(query)
        tickets = result.scalars().all()
        
        return tickets
